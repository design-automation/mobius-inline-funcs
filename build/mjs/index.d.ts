import { TPlane, TRay, Txyz } from './libs/common';
import { abs } from './inline/arithmetic/abs';
import { square } from './inline/arithmetic/square';
import { cube } from './inline/arithmetic/cube';
import { pow } from './inline/arithmetic/pow';
import { sqrt } from './inline/arithmetic/sqrt';
import { exp } from './inline/arithmetic/exp';
import { log } from './inline/arithmetic/log';
import { log10 } from './inline/arithmetic/log10';
import { round } from './inline/arithmetic/round';
import { sigFig } from './inline/arithmetic/sigFig';
import { ceil } from './inline/arithmetic/ceil';
import { floor } from './inline/arithmetic/floor';
import { sum } from './inline/arithmetic/sum';
import { prod } from './inline/arithmetic/prod';
import { hypot } from './inline/arithmetic/hypot';
import { norm } from './inline/arithmetic/norm';
import { isApprox } from './inline/arithmetic/isApprox';
import { isIn } from './inline/arithmetic/isIn';
import { isWithin } from './inline/arithmetic/isWithin';
import { remap } from './inline/arithmetic/remap';
export { abs };
export { square };
export { cube };
export { pow };
export { sqrt };
export { exp };
export { log };
export { log10 };
export { round };
export { sigFig };
export { ceil };
export { floor };
export { sum };
export { prod };
export { hypot };
export { norm };
export { isApprox };
export { isIn };
export { isWithin };
export { remap };
import { colFalse } from './inline/colors/colFalse';
import { colScale } from './inline/colors/colScale';
import { colFromStr } from './inline/colors/colFromStr';
export { colFalse };
export { colScale };
export { colFromStr };
import { boolean } from './inline/conversion/boolean';
import { number } from './inline/conversion/number';
import { string } from './inline/conversion/string';
import { radToDeg } from './inline/conversion/radToDeg';
import { degToRad } from './inline/conversion/degToRad';
import { numToStr } from './inline/conversion/numToStr';
import { numToCurr } from './inline/conversion/numToCurr';
export { boolean };
export { number };
export { string };
export { radToDeg };
export { degToRad };
export { numToStr };
export { numToCurr };
import { dictGet } from './inline/dict/dictGet';
import { dictKeys } from './inline/dict/dictKeys';
import { dictVals } from './inline/dict/dictVals';
import { dictHasKey } from './inline/dict/dictHasKey';
import { dictHasVal } from './inline/dict/dictHasVal';
import { dictFind } from './inline/dict/dictFind';
import { dictCopy } from './inline/dict/dictCopy';
import { dictEq } from './inline/dict/dictEq';
export { dictGet };
export { dictKeys };
export { dictVals };
export { dictHasKey };
export { dictHasVal };
export { dictFind };
export { dictCopy };
export { dictEq };
import { intersect } from './inline/geometry/intersect';
import { project } from './inline/geometry/project';
import { distance } from './inline/geometry/distance';
import { distanceM } from './inline/geometry/distanceM';
import { distanceMS } from './inline/geometry/distanceMS';
export { intersect };
export { project };
export { distance };
export { distanceM };
export { distanceMS };
import { listCopy } from './inline/list/listCopy';
import { listCount } from './inline/list/listCount';
import { listCull } from './inline/list/listCull';
import { listEq } from './inline/list/listEq';
import { listFind } from './inline/list/listFind';
import { listFlat } from './inline/list/listFlat';
import { listGet } from './inline/list/listGet';
import { listHas } from './inline/list/listHas';
import { listJoin } from './inline/list/listJoin';
import { listRep } from './inline/list/listRep';
import { listRev } from './inline/list/listRev';
import { listRot } from './inline/list/listRot';
import { listSlice } from './inline/list/listSlice';
import { listSort } from './inline/list/listSort';
import { listZip } from './inline/list/listZip';
import { range } from './inline/list/range';
export { listCopy };
export { listCount };
export { listCull };
export { listEq };
export { listFind };
export { listFlat };
export { listGet };
export { listHas };
export { listJoin };
export { listRep };
export { listRev };
export { listRot };
export { listSlice };
export { listSort };
export { listZip };
export { range };
import { plnMake } from './inline/plane/plnMake';
import { plnCopy } from './inline/plane/plnCopy';
import { plnMove } from './inline/plane/plnMove';
import { plnRot } from './inline/plane/plnRot';
import { plnLMove } from './inline/plane/plnLMove';
import { plnLRotX } from './inline/plane/plnLRotX';
import { plnLRotY } from './inline/plane/plnLRotY';
import { plnLRotZ } from './inline/plane/plnLRotZ';
import { plnFromRay } from './inline/plane/plnFromRay';
export { plnMake };
export { plnCopy };
export { plnMove };
export { plnRot };
export { plnLMove };
export { plnLRotX };
export { plnLRotY };
export { plnLRotZ };
export { plnFromRay };
import { rand } from './inline/rand/rand';
import { randInt } from './inline/rand/randInt';
import { randPick } from './inline/rand/randPick';
export { rand };
export { randInt };
export { randPick };
import { rayMake } from './inline/ray/rayMake';
import { rayFromTo } from './inline/ray/rayFromTo';
import { rayCopy } from './inline/ray/rayCopy';
import { rayMove } from './inline/ray/rayMove';
import { rayRot } from './inline/ray/rayRot';
import { rayLMove } from './inline/ray/rayLMove';
import { rayFromPln } from './inline/ray/rayFromPln';
import { rayLtoG } from './inline/ray/rayLtoG';
import { rayGtoL } from './inline/ray/rayGtoL';
export { rayMake };
export { rayFromTo };
export { rayCopy };
export { rayMove };
export { rayRot };
export { rayLMove };
export { rayFromPln };
export { rayLtoG };
export { rayGtoL };
import { setMake } from './inline/set/setMake';
import { setUni } from './inline/set/setUni';
import { setInt } from './inline/set/setInt';
import { setDif } from './inline/set/setDif';
export { setMake };
export { setUni };
export { setInt };
export { setDif };
import { min } from './inline/statistics/min';
import { max } from './inline/statistics/max';
import { mad } from './inline/statistics/mad';
import { mean } from './inline/statistics/mean';
import { median } from './inline/statistics/median';
import { mode } from './inline/statistics/mode';
import { std } from './inline/statistics/std';
import { vari } from './inline/statistics/vari';
export { min };
export { max };
export { mad };
export { mean };
export { median };
export { mode };
export { std };
export { vari };
import { strRepl } from './inline/strs/strRepl';
import { strUpp } from './inline/strs/strUpp';
import { strLow } from './inline/strs/strLow';
import { strTrim } from './inline/strs/strTrim';
import { strTrimR } from './inline/strs/strTrimR';
import { strTrimL } from './inline/strs/strTrimL';
import { strPadL } from './inline/strs/strPadL';
import { strPadR } from './inline/strs/strPadR';
import { strSub } from './inline/strs/strSub';
import { strStarts } from './inline/strs/strStarts';
import { strEnds } from './inline/strs/strEnds';
import { strToJSON } from './inline/strs/strToJSON';
export { strRepl };
export { strUpp };
export { strLow };
export { strTrim };
export { strTrimR };
export { strTrimL };
export { strPadL };
export { strPadR };
export { strSub };
export { strStarts };
export { strEnds };
export { strToJSON };
import { sin } from './inline/Trigonometry/sin';
import { asin } from './inline/Trigonometry/asin';
import { sinh } from './inline/Trigonometry/sinh';
import { asinh } from './inline/Trigonometry/asinh';
import { cos } from './inline/Trigonometry/cos';
import { acos } from './inline/Trigonometry/acos';
import { cosh } from './inline/Trigonometry/cosh';
import { acosh } from './inline/Trigonometry/acosh';
import { tan } from './inline/Trigonometry/tan';
import { atan } from './inline/Trigonometry/atan';
import { atan2 } from './inline/Trigonometry/atan2';
import { tanh } from './inline/Trigonometry/tanh';
import { atanh } from './inline/Trigonometry/atanh';
export { sin };
export { asin };
export { sinh };
export { asinh };
export { cos };
export { acos };
export { cosh };
export { acosh };
export { tan };
export { atan };
export { atan2 };
export { tanh };
export { atanh };
import { isNum } from "./inline/types/isNum";
import { isInt } from "./inline/types/isInt";
import { isFlt } from "./inline/types/isFlt";
import { isBool } from "./inline/types/isBool";
import { isStr } from "./inline/types/isStr";
import { isList } from "./inline/types/isList";
import { isDict } from "./inline/types/isDict";
import { isVec2 } from "./inline/types/isVec2";
import { isVec3 } from "./inline/types/isVec3";
import { isCol } from "./inline/types/isCol";
import { isRay } from "./inline/types/isRay";
import { isPln } from "./inline/types/isPln";
import { isNaN } from "./inline/types/isNaN";
import { isNull } from "./inline/types/isNull";
import { isUndef } from "./inline/types/isUndef";
import { _isWithin } from "./inline/types/common";
export { isNum };
export { isInt };
export { isFlt };
export { isBool };
export { isStr };
export { isList };
export { isDict };
export { isVec2 };
export { isVec3 };
export { isCol };
export { isRay };
export { isPln };
export { isNaN };
export { isNull };
export { isUndef };
export { _isWithin };
import { vecSum } from './inline/vec/vecSum';
import { vecAvg } from './inline/vec/vecAvg';
import { vecAvgDir } from './inline/vec/vecAvgDir';
import { vecAdd } from './inline/vec/vecAdd';
import { vecSub } from './inline/vec/vecSub';
import { vecDiv } from './inline/vec/vecDiv';
import { vecMult } from './inline/vec/vecMult';
import { vecSetLen } from './inline/vec/vecSetLen';
import { vecDot } from './inline/vec/vecDot';
import { vecCross } from './inline/vec/vecCross';
import { vecAng } from './inline/vec/vecAng';
import { vecFromTo } from './inline/vec/vecFromTo';
import { vecEqual } from './inline/vec/vecEqual';
import { vecAng2 } from './inline/vec/vecAng2';
import { vecRot } from './inline/vec/vecRot';
import { vecLen } from './inline/vec/vecLen';
import { vecNorm } from './inline/vec/vecNorm';
import { vecRev } from './inline/vec/vecRev';
import { vecLtoG } from './inline/vec/vecLtoG';
import { vecGtoL } from './inline/vec/vecGtoL';
export { vecSum };
export { vecAvg };
export { vecAvgDir };
export { vecAdd };
export { vecSub };
export { vecDiv };
export { vecMult };
export { vecSetLen };
export { vecDot };
export { vecCross };
export { vecAng };
export { vecFromTo };
export { vecEqual };
export { vecAng2 };
export { vecRot };
export { vecLen };
export { vecNorm };
export { vecRev };
export { vecLtoG };
export { vecGtoL };
export declare class InlineFuncs {
    __debug__: boolean;
    constructor(debug?: boolean);
    PI: number;
    XY: TPlane;
    XZ: TPlane;
    YX: TPlane;
    YZ: TPlane;
    ZX: TPlane;
    ZY: TPlane;
    VX: Txyz;
    VY: Txyz;
    VZ: Txyz;
    VO: Txyz;
    RX: TRay;
    RY: TRay;
    RZ: TRay;
    EUL: number;
    PI2: number;
    abs(num: number | number[]): number | number[];
    square(list: number | number[]): any;
    cube(list: number | number[]): any;
    pow(base: number | number[], xp: number): number | number[];
    sqrt(num: number | number[]): number | number[];
    exp(num: number | number[]): number | number[];
    log(base: number | number[]): number | number[];
    log10(base: number | number[]): number | number[];
    round(num: number | number[], dec_pla?: number): number | number[];
    sigFig(num: number | number[], sig_figs: number): number | number[];
    ceil(num: number | number[]): number | number[];
    floor(num: number | number[]): number | number[];
    sum(list: number | number[]): any;
    prod(list: number | number[]): any;
    hypot(list: number | number[]): any;
    norm(list: number | number[]): any;
    isApprox(n1: number, n2: number, t: number): boolean;
    isIn(v1: number, v2: number, v3: number): boolean;
    isWithin(v1: number, v2: number, v3: number): boolean;
    remap(num: number | number[], d1: number[], d2: number[]): number | number[];
    colFalse(vals: number | number[], min: number, max: number): import("./libs/common").TColor | import("./libs/common").TColor[];
    colScale(vals: number | number[], min: number, max: number, scale: any): import("./libs/common").TColor | import("./libs/common").TColor[];
    colFromStr(col_str: string | string[]): import("./libs/common").TColor | import("./libs/common").TColor[];
    boolean(val: number | string): any;
    number(val: any): any;
    string(val: any): any;
    radToDeg(rad: number | number[]): number | number[];
    degToRad(deg: number | number[]): number | number[];
    numToStr(num: number | number[], frac_digits?: number, locale?: string): string | string[];
    numToCurr(num: number | number[], currency: string, locale?: string): string | string[];
    dictGet(dict: object, key: string | string[]): any;
    dictKeys(dict: object): string[];
    dictVals(dict: object): string[];
    dictHasKey(dict: object, key: string | string[]): boolean | boolean[];
    dictHasVal(dict: object, val: any): boolean;
    dictFind(dict: object, val: string): string;
    dictCopy(dict: object): object;
    dictEq(dict1: any[], dict2: any[]): boolean;
    intersect(r1: TRay, r2: TRay | TPlane, met?: number): [number, number, number];
    project(c: Txyz, r: TRay | TPlane, met?: number): [number, number, number];
    distance(c1: Txyz, c2: Txyz | TRay | TPlane): number;
    distanceM(c1: Txyz, c2: Txyz | TRay | TPlane): number;
    distanceMS(c1: Txyz, c2: Txyz | TRay | TPlane): number;
    listCopy(list: any[]): any[];
    listCount(list: any[], val: number): number;
    listCull(list1: any[], list2: any[]): any[];
    listEq(list1: any[], list2: any[]): boolean;
    listFind(list: any[], val: string): number;
    listFlat(list: any[], depth: number): any[];
    listGet(list: any[], idx: number | number[]): any;
    listHas(list: any[], val: undefined): boolean;
    listJoin(...lists: any[]): any[];
    listRep(list: number[], n: number): any[];
    listRev(list: any[]): any[];
    listRot(list: any[], rot: number): any[];
    listSlice(list: any[], start: number, end: number): any[];
    listSort(list1: any[], list2: any[]): any[];
    listZip(...list: any[]): any[];
    range(start: number, end: number, step: number): number[];
    plnMake(origin: Txyz | Txyz[], x_vec: Txyz | Txyz[], xy_vec: Txyz | Txyz[]): TPlane | TPlane[];
    plnCopy(pln: TPlane | TPlane[]): TPlane | TPlane[];
    plnMove(pln: TPlane | TPlane[], vec: Txyz | Txyz[]): TPlane | TPlane[];
    plnRot(pln: TPlane | TPlane[], ray: TRay | TRay[], ang: number | number[]): TPlane | TPlane[];
    plnLMove(pln: TPlane | TPlane[], vec: Txyz | Txyz[]): TPlane | TPlane[];
    plnLRotX(pln: TPlane | TPlane[], ang: number | number[]): TPlane | TPlane[];
    plnLRotY(pln: TPlane | TPlane[], ang: number | number[]): TPlane | TPlane[];
    plnLRotZ(pln: TPlane | TPlane[], ang: number | number[]): TPlane | TPlane[];
    plnFromRay(ray: TRay | TRay[]): TPlane | TPlane[];
    rand(min: number, max: number, seed?: number): number;
    randInt(min: number, max: number, seed?: number): number;
    randPick(list: any[], num: number, seed?: number): number | number[];
    rayMake(origin: Txyz | Txyz[], dir: Txyz | Txyz[], len?: number): TRay | TRay[];
    rayFromTo(xyz1: Txyz | Txyz[], xyz2: Txyz | Txyz[]): TRay | TRay[];
    rayCopy(ray: TRay | TRay[]): TRay | TRay[];
    rayMove(ray: TRay | TRay[], vec: Txyz | Txyz[]): TRay | TRay[];
    rayRot(ray1: TRay | TRay[], ray2: TRay | TRay[], ang: number | number[]): TRay | TRay[];
    rayLMove(ray: TRay | TRay[], dist: number | number[]): TRay | TRay[];
    rayFromPln(pln: TPlane | TPlane[]): TRay | TRay[];
    rayLtoG(r: TRay | TRay[], p: TPlane | TPlane[]): TRay | TRay[];
    rayGtoL(r: TRay | TRay[], p: TPlane | TPlane[]): TRay | TRay[];
    setMake(list: any[]): any[];
    setUni(list1: any[], list2: any[]): any[];
    setInt(list1: any[], list2: any[]): any[];
    setDif(list1: any[], list2: any[]): any[];
    min(list: any): any;
    max(list: any): any;
    mad(list: number[]): any;
    mean(list: number[]): any;
    median(list: number[]): any;
    mode(list: any[]): any;
    std(list: number[]): any;
    vari(list: number[]): any;
    strRepl(str: any, search_str: any, new_str: any): string | string[];
    strUpp(str: any): string | string[];
    strLow(str: any): string | string[];
    strTrim(str: any): string | string[];
    strTrimR(str: any): string | string[];
    strTrimL(str: any): string | string[];
    strPadL(str: any, max: any, fill: any): string | string[];
    strPadR(str: any, max: any, fill: any): string | string[];
    strSub(str: any, from: any, length: any): string | string[];
    strStarts(str: any, starts: any): boolean | boolean[];
    strEnds(str: any, ends: any): boolean | boolean[];
    strToJSON(str: any): any;
    sin(num: number | number[]): number | number[];
    asin(num: number | number[]): number | number[];
    sinh(num: number | number[]): number | number[];
    asinh(num: number | number[]): number | number[];
    cos(num: number | number[]): number | number[];
    acos(num: number | number[]): number | number[];
    cosh(num: number | number[]): number | number[];
    acosh(num: number | number[]): number | number[];
    tan(num: number | number[]): number | number[];
    atan(num: number | number[]): number | number[];
    atan2(xy: [number, number] | [number, number][]): number | number[];
    tanh(num: number | number[]): number | number[];
    atanh(num: number | number[]): number | number[];
    isNum(v: any): boolean;
    isInt(v: any): boolean;
    isFlt(v: any): boolean;
    isBool(v: any): boolean;
    isStr(v: any): boolean;
    isList(v: any): boolean;
    isDict(v: any): boolean;
    isVec2(v: any): boolean;
    isVec3(v: any): boolean;
    isCol(v: any): boolean;
    isRay(v: any): boolean;
    isPln(v: any): boolean;
    isNaN(v: any): boolean;
    isNull(v: any): boolean;
    isUndef(v: any): boolean;
    _isWithin(v1: any, v2: any, v3: any): boolean;
    vecSum(...v: Txyz[]): Txyz;
    vecAvg(...v: Txyz[]): Txyz;
    vecAvgDir(...v: Txyz[]): Txyz;
    vecAdd(v1: Txyz | Txyz[], v2: Txyz | Txyz[], norm: boolean): Txyz | Txyz[];
    vecSub(v1: Txyz | Txyz[], v2: Txyz | Txyz[], norm: boolean): Txyz | Txyz[];
    vecDiv(v: Txyz | Txyz[], num: number | number[]): Txyz | Txyz[];
    vecMult(v: Txyz | Txyz[], num: number | number[]): Txyz | Txyz[];
    vecSetLen(v: Txyz | Txyz[], num: number | number[]): Txyz | Txyz[];
    vecDot(v1: Txyz | Txyz[], v2: Txyz | Txyz[]): number | number[];
    vecCross(v1: Txyz | Txyz[], v2: Txyz | Txyz[]): Txyz | Txyz[];
    vecAng(v1: Txyz | Txyz[], v2: Txyz | Txyz[]): number | number[];
    vecFromTo(xyz1: Txyz | Txyz[], xyz2: Txyz | Txyz[]): Txyz | Txyz[];
    vecEqual(v1: Txyz | Txyz[], v2: Txyz | Txyz[], tol: number): boolean | boolean[];
    vecAng2(v1: Txyz | Txyz[], v2: Txyz | Txyz[], v3: Txyz | Txyz[]): number | number[];
    vecRot(v1: Txyz | Txyz[], v2: Txyz | Txyz[], ang: number | number[]): Txyz | Txyz[];
    vecLen(v: Txyz | Txyz[]): number | number[];
    vecNorm(v: Txyz | Txyz[]): Txyz | Txyz[];
    vecRev(v: Txyz | Txyz[]): Txyz | Txyz[];
    vecLtoG(v: Txyz | Txyz[], p: TPlane | TPlane[]): Txyz | Txyz[];
    vecGtoL(v: Txyz | Txyz[], p: TPlane | TPlane[]): Txyz | Txyz[];
    len(data: any): number;
    copy(data: any): any;
    equal(data1: any, data2: any): boolean;
}
